batch service

package com.training.springusecasewithjpa.service;

import com.training.springusecasewithjpa.entities.Batch;
import com.training.springusecasewithjpa.entities.PayrollEntry;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;

public interface BatchService {
    List<Batch> getAllBatches();
    Batch getBatchById(String id);
    Batch createBatch(Batch batch);
    Batch updateBatch(String id, Batch batch);
    void deleteBatch(String id);

    List<PayrollEntry> getPayrollEntries(String batchId);
    PayrollEntry addPayrollEntry(String batchId, PayrollEntry entry);
    PayrollEntry updatePayrollEntry(Long id, PayrollEntry entry);
    void deletePayrollEntry(Long id);

    void uploadPayrollEntriesFromExcel(String batchId, MultipartFile file) throws IOException;
}

batch service impl

package com.training.springusecasewithjpa.service;

import com.training.springusecasewithjpa.dao.BatchRepository;
import com.training.springusecasewithjpa.entities.Batch;
import com.training.springusecasewithjpa.entities.PayrollEntry;
import com.training.springusecasewithjpa.exceptions.BatchNotFoundException;
import com.training.springusecasewithjpa.exceptions.DataNotFoundException;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.List;

@Service
public class BatchServiceImpl implements BatchService {

    @Autowired
    private BatchRepository batchRepository;

    @Override
    public List<Batch> getAllBatches() {
        return batchRepository.findAll();
    }

    @Override
    public Batch getBatchById(String id) {
        return batchRepository.findById(id)
                .orElseThrow(() -> new BatchNotFoundException("Batch not found with id: " + id));
    }

    @Override
    public Batch createBatch(Batch batch) {
        return batchRepository.save(batch);
    }

    @Override
    public Batch updateBatch(String id, Batch batchDetails) {
        Batch batch = getBatchById(id);
        batch.setName(batchDetails.getName());
        batch.setStatus(batchDetails.getStatus());
        batch.setPaymentDate(batchDetails.getPaymentDate());
        batch.setPaymentType(batchDetails.getPaymentType());
        batch.setDebitAccount(batchDetails.getDebitAccount());
        batch.setAccountType(batchDetails.getAccountType());
        return batchRepository.save(batch);
    }

    @Override
    public void deleteBatch(String id) {
        Batch batch = getBatchById(id);
        batchRepository.delete(batch);
    }

    @Override
    public List<PayrollEntry> getPayrollEntries(String batchId) {
        Batch batch = getBatchById(batchId);
        return batch.getEntries();
    }

    @Override
    public PayrollEntry addPayrollEntry(String batchId, PayrollEntry entry) {
        Batch batch = getBatchById(batchId);
        entry.setBatch(batch);
        PayrollEntry savedEntry = batchRepository.save(batch).getEntries().stream()
                .filter(e -> e.getBatch().getId().equals(batchId))
                .findFirst()
                .orElse(null);
        return savedEntry;
    }

    @Override
    public PayrollEntry updatePayrollEntry(Long id, PayrollEntry entryDetails) {
        // This is a simplified implementation
        // In a real app, you'd need proper entry retrieval and update logic
        throw new UnsupportedOperationException("Update payroll entry not implemented");
    }

    @Override
    public void deletePayrollEntry(Long id) {
        // This is a simplified implementation
        throw new UnsupportedOperationException("Delete payroll entry not implemented");
    }

    @Override
    public void uploadPayrollEntriesFromExcel(String batchId, MultipartFile file) throws IOException {
        Workbook workbook = new XSSFWorkbook(file.getInputStream());
        Sheet sheet = workbook.getSheetAt(0);

        for (int i = 1; i <= sheet.getLastRowNum(); i++) { // Skip header row
            Row row = sheet.getRow(i);
            if (row != null) {
                String payeeName = getStringCellValue(row.getCell(0));
                String bankDetails = getStringCellValue(row.getCell(1));
                String yourReference = getStringCellValue(row.getCell(2));
                String paymentReference = getStringCellValue(row.getCell(3));
                String amountStr = getStringCellValue(row.getCell(4));

                BigDecimal amount = new BigDecimal(amountStr);

                PayrollEntry entry = new PayrollEntry();
                entry.setPayeeName(payeeName);
                entry.setBankDetails(bankDetails);
                entry.setYourReference(yourReference);
                entry.setPaymentReference(paymentReference);
                entry.setAmount(amount);
                entry.setMethod("NEFT"); // Default method
                entry.setPayeeDetails("Empl"); // Default type

                // Add to batch (simplified)
                Batch batch = getBatchById(batchId);
                entry.setBatch(batch);
            }
        }

        workbook.close();
    }

    private String getStringCellValue(Cell cell) {
        if (cell == null) return "";
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(cell)) {
                    return cell.getDateCellValue().toString();
                } else {
                    return String.valueOf(cell.getNumericCellValue());
                }
            case BOOLEAN:
                return String.valueOf(cell.getBooleanCellValue());
            case FORMULA:
                return cell.getCellFormula();
            default:
                return "";
        }
    }
}

batch entity

package com.training.springusecasewithjpa.entities;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Entity
@Table(name = "batches")
public class Batch {

    @Id
    private String id;

    @Column(name = "name")
    private String name;

    @Column(name = "status")
    private String status = "draft";

    @Column(name = "total_amount")
    private BigDecimal totalAmount = BigDecimal.ZERO;

    @Column(name = "payment_date")
    private LocalDate paymentDate;

    @Column(name = "payment_type")
    private String paymentType;

    @Column(name = "currency")
    private String currency = "INR";

    @Column(name = "debit_account")
    private String debitAccount;

    @Column(name = "account_type")
    private String accountType;

    @OneToMany(mappedBy = "batch", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<PayrollEntry> entries;

    // Constructors
    public Batch() {}

    public Batch(String id, String name) {
        this.id = id;
        this.name = name;
    }

    // Getters and Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public BigDecimal getTotalAmount() { return totalAmount; }
    public void setTotalAmount(BigDecimal totalAmount) { this.totalAmount = totalAmount; }

    public LocalDate getPaymentDate() { return paymentDate; }
    public void setPaymentDate(LocalDate paymentDate) { this.paymentDate = paymentDate; }

    public String getPaymentType() { return paymentType; }
    public void setPaymentType(String paymentType) { this.paymentType = paymentType; }

    public String getCurrency() { return currency; }
    public void setCurrency(String currency) { this.currency = currency; }

    public String getDebitAccount() { return debitAccount; }
    public void setDebitAccount(String debitAccount) { this.debitAccount = debitAccount; }

    public String getAccountType() { return accountType; }
    public void setAccountType(String accountType) { this.accountType = accountType; }

    public List<PayrollEntry> getEntries() { return entries; }
    public void setEntries(List<PayrollEntry> entries) { this.entries = entries; }
}

batch repository

package com.training.springusecasewithjpa.dao;

import com.training.springusecasewithjpa.entities.Batch;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface BatchRepository extends JpaRepository<Batch, String> {
    // JpaRepository provides all basic CRUD operations automatically
    // You can add custom query methods here if needed
}

batch controller

package com.training.springusecasewithjpa.controller;

import com.training.springusecasewithjpa.entities.Batch;
import com.training.springusecasewithjpa.entities.PayrollEntry;
import com.training.springusecasewithjpa.service.BatchService;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@RestController
@RequestMapping("/api/batches")
@Tag(name = "Batch Management", description = "Operations related to payroll batch management")
public class BatchController {

    @Autowired
    private BatchService batchService;

    @GetMapping
    public ResponseEntity<List<Batch>> getAllBatches() {
        return ResponseEntity.ok(batchService.getAllBatches());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Batch> getBatchById(@PathVariable String id) {
        return ResponseEntity.ok(batchService.getBatchById(id));
    }

    @PostMapping
    public ResponseEntity<Batch> createBatch(@RequestBody Batch batch) {
        return ResponseEntity.ok(batchService.createBatch(batch));
    }

    @PutMapping("/{id}")
    public ResponseEntity<Batch> updateBatch(@PathVariable String id, @RequestBody Batch batch) {
        return ResponseEntity.ok(batchService.updateBatch(id, batch));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteBatch(@PathVariable String id) {
        batchService.deleteBatch(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/{batchId}/entries")
    public ResponseEntity<List<PayrollEntry>> getPayrollEntries(@PathVariable String batchId) {
        return ResponseEntity.ok(batchService.getPayrollEntries(batchId));
    }

    @PostMapping("/{batchId}/entries")
    public ResponseEntity<PayrollEntry> addPayrollEntry(@PathVariable String batchId, @RequestBody PayrollEntry entry) {
        return ResponseEntity.ok(batchService.addPayrollEntry(batchId, entry));
    }

    @PutMapping("/entries/{id}")
    public ResponseEntity<PayrollEntry> updatePayrollEntry(@PathVariable Long id, @RequestBody PayrollEntry entry) {
        return ResponseEntity.ok(batchService.updatePayrollEntry(id, entry));
    }

    @DeleteMapping("/entries/{id}")
    public ResponseEntity<Void> deletePayrollEntry(@PathVariable Long id) {
        batchService.deletePayrollEntry(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/upload/excel/{batchId}")
    public ResponseEntity<String> uploadExcel(@PathVariable String batchId, @RequestParam("file") MultipartFile file) {
        try {
            batchService.uploadPayrollEntriesFromExcel(batchId, file);
            return ResponseEntity.ok("Successfully uploaded payroll entries from Excel");
        } catch (Exception e) {
            return ResponseEntity.status(500).body("Error uploading Excel file: " + e.getMessage());
        }
    }
}
